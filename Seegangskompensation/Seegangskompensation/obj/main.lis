                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           L2:
 0000 5465737400        .byte 'T,'e,'s,'t,0
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Lesky\Desktop\Dropbox\Studium\Bechlor\SOFTWA~1\neu\SEEGAN~1\SEEGAN~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ; kochPeriodendauer -> X+13
 0000           ; pdchEntfernung -> X+12
 0000           ;         kochKS -> X+11
 0000           ;         kochKP -> X+10
 0000           ;        rgchLCD -> X+5
 0000           ;   pbchSollwert -> X+4
 0000           ;  pbchPulsweite -> X+3
 0000           ; hichBeschleunigungssumme -> X+2
 0000           ; hichAusgangswert -> X+1
 0000           ; pdchBechleunigung -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 380E              add SP,14
 0004                   .dbline 12
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; // Programm: Seegangskompensation bei Krahnanlagen
 0004           ; // Version: 0.0.0.1
 0004           ; // Controler: CY8C27446-24PXI
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 14
 0004           ;       // Difinition der Konstanten
 0004           ;       char kochPeriodendauer = 50;                                    // Periodendauer
 0004 560D32            mov [X+13],50
 0007                   .dbline 21
 0007           ;       char kochKP;
 0007           ;       char kochKS;
 0007           ;       
 0007           ;       
 0007           ;       // Variablendeklration
 0007           ;       
 0007           ;       char rgchLCD[] = "Test";                                                
 0007 550000            mov [__r1],<L2
 000A 550000            mov [__r0],>L2
 000D 5A00              mov [__r3],X
 000F 060005            add [__r3],5
 0012 10                push X
 0013 550000            mov [__rX],0
 0016 5100              mov A,[__r0]
 0018 5800              mov X,[__r1]
 001A           X1:
 001A 08                push A
 001B 28                romx
 001C 3F00              mvi [__r3],A
 001E 18                pop A
 001F 75                inc X
 0020 0900              adc A,0
 0022 7600              inc [__rX]
 0024 3C0005            cmp [__rX],5
 0027 BFF2              jnz X1
 0029 20                pop X
 002A                   .dbline 30
 002A           ;       char pdchBechleunigung, pdchEntfernung;                 
 002A           ;       char pbchSollwert;                                                              
 002A           ;       char pbchPulsweite;
 002A           ;       char hichAusgangswert;                                                  
 002A           ;       char hichBeschleunigungssumme;
 002A           ;               
 002A           ;       // Initialisierung des Controlers
 002A           ;       
 002A           ;       M8C_EnableGInt;                                         // Enable global interrupts     
 002A 7101                      or  F, 01h
 002C           
 002C                   .dbline 32
 002C           ;       
 002C           ;       LCD_1_Start();                                                  // Initialisieren des LCD-Displays
 002C 10                push X
 002D 7C0000            xcall _LCD_1_Start
 0030 20                pop X
 0031                   .dbline 34
 0031           ;       
 0031           ;       PWM8_1_WritePeriod(kochPeriodendauer);          // Initialisieren der PWM-Module                    
 0031 10                push X
 0032 520D              mov A,[X+13]
 0034 7C0000            xcall _PWM8_1_WritePeriod
 0037                   .dbline 35
 0037           ;     PWM8_1_Start();
 0037 7C0000            xcall _PWM8_1_Start
 003A                   .dbline 37
 003A           ; 
 003A           ;       DUALADC8_Start(DUALADC8_HIGHPOWER);                     // Initialisieren des Dualen AD-Wandlers
 003A 5003              mov A,3
 003C 7C0000            xcall _DUALADC8_Start
 003F                   .dbline 38
 003F           ;       DUALADC8_SetCalcTime(100);                              // für Entfernung und Beschleunigung
 003F 5700              mov X,0
 0041 5064              mov A,100
 0043 7C0000            xcall _DUALADC8_SetCalcTime
 0046                   .dbline 39
 0046           ;       DUALADC8_GetSamples(); 
 0046 7C0000            xcall _DUALADC8_GetSamples
 0049                   .dbline 41
 0049           ;       
 0049           ;       ADCINC_Start(ADCINC_HIGHPOWER);                         // Initialisieren des AD-Wandlers
 0049 5003              mov A,3
 004B 7C0000            xcall _ADCINC_Start
 004E                   .dbline 42
 004E           ;       ADCINC_GetSamples(0);                                   // für den Sollwert
 004E 5000              mov A,0
 0050 7C0000            xcall _ADCINC_GetSamples
 0053 20                pop X
 0054                   .dbline 44
 0054           ;       
 0054           ;       DIGITALOUT_Start;                                                               //Initialisieren der Digitalen Ausgangs
 0054 809D              xjmp L4
 0056           L3:
 0056                   .dbline 47
 0056           ;       
 0056           ;       // Endlosschleife
 0056           ;       while(1) {
 0056                   .dbline 50
 0056           ;       
 0056           ;               // Daten Einlesen
 0056           ;               if(ADCINC_fIsDataAvailable() != 0)                      // Wenn Sollwertdaten bereit sind
 0056 10                push X
 0057 7C0000            xcall _ADCINC_fIsDataAvailable
 005A 20                pop X
 005B 3900              cmp A,0
 005D A008              jz L9
 005F                   .dbline 51
 005F           ;               pbchSollwert = ADCINC_cClearFlagGetData();              // Einlesen des Sollwertes
 005F 10                push X
 0060 7C0000            xcall _ADCINC_cClearFlagGetData
 0063 20                pop X
 0064 5404              mov [X+4],A
 0066           L8:
 0066                   .dbline 54
 0066           ;                                                                       // data ready flag zurüvksetzen
 0066           ;                          
 0066           ;       while(DUALADC8_fIsDataAvailable == 0);                  // Auf Entfernung und Position Warten
 0066           L9:
 0066                   .dbline 54
 0066 5000              mov A,<PL_DUALADC8_fIsDataAvailable
 0068 10                push X
 0069 5800              mov X,[__r1]
 006B 08                push A
 006C 28                romx
 006D 5300              mov [__r0],A
 006F 18                pop A
 0070 75                inc X
 0071 0900              adc A,0
 0073 28                romx
 0074 20                pop X
 0075 3C0000            cmp [__r0],0
 0078 AFED              jz L8
 007A                   .dbline 55
 007A           ;               pdchBechleunigung = DUALADC8_cGetData1();       // Einlesen der Beschleunigung
 007A 10                push X
 007B 7C0000            xcall _DUALADC8_cGetData1
 007E 20                pop X
 007F 5400              mov [X+0],A
 0081                   .dbline 56
 0081           ;       pdchEntfernung = DUALADC8_cGetData2ClearFlag(); // Einlesen der Entfernung
 0081 10                push X
 0082 7C0000            xcall _DUALADC8_cGetData2ClearFlag
 0085 20                pop X
 0086 540C              mov [X+12],A
 0088                   .dbline 60
 0088           ;                                                                       // data ready flag zurüvksetzen                                    
 0088           ;               // Parameter Berechnen
 0088           ;               
 0088           ;               hichBeschleunigungssumme = hichBeschleunigungssumme + pdchBechleunigung;
 0088 5200              mov A,[X+0]
 008A 0502              add [X+2],A
 008C                   .dbline 62
 008C           ;               
 008C           ;               hichAusgangswert = ( pbchSollwert - pdchBechleunigung ) * kochKP
 008C 520B              mov A,[X+11]
 008E 08                push A
 008F 5001              mov A,1
 0091 08                push A
 0092 7C0000            xcall __divmodu_8X8_8
 0095 18                pop A
 0096 5300              mov [__r0],A
 0098 38FF              add SP,-1
 009A 5202              mov A,[X+2]
 009C 60E8              mov REG[0xe8],A
 009E 5100              mov A,[__r0]
 00A0 60E9              mov REG[0xe9],A
 00A2 40                nop
 00A3 5DEB              mov A,REG[0xeb]
 00A5 5300              mov [__r0],A
 00A7 5204              mov A,[X+4]
 00A9 1300              sub A,[X+0]
 00AB 5300              mov [__r2],A
 00AD 520A              mov A,[X+10]
 00AF 60E8              mov REG[0xe8],A
 00B1 5100              mov A,[__r2]
 00B3 60E9              mov REG[0xe9],A
 00B5 40                nop
 00B6 5DEB              mov A,REG[0xeb]
 00B8 1200              sub A,[__r0]
 00BA 5401              mov [X+1],A
 00BC                   .dbline 65
 00BC           ;                                                       - 1 / kochKS * hichBeschleunigungssumme;
 00BC           ;               
 00BC           ;               pbchPulsweite = hichAusgangswert; //TODO: Korekturfaktor Einfügen 
 00BC 5201              mov A,[X+1]
 00BE 5403              mov [X+3],A
 00C0                   .dbline 69
 00C0           ;               // Ausgang Setzen
 00C0           ;                               
 00C0           ;               // positive Drehrichtung
 00C0           ;               if (hichAusgangswert >= 0){                             
 00C0 3D0100            cmp [X+1],0
 00C3 C00A              jc L11
 00C5           X2:
 00C5                   .dbline 70
 00C5           ;                       DIGITALOUT_On;
 00C5                   .dbline 70
 00C5                   .dbline 71
 00C5           ;                       PWM8_1_WritePulseWidth(pbchPulsweite);
 00C5 10                push X
 00C6 5203              mov A,[X+3]
 00C8 7C0000            xcall _PWM8_1_WritePulseWidth
 00CB 20                pop X
 00CC                   .dbline 72
 00CC           ;               }
 00CC 800B              xjmp L12
 00CE           L11:
 00CE                   .dbline 74
 00CE           ;               // negative Drehrichtung
 00CE           ;               else {                          
 00CE                   .dbline 75
 00CE           ;                       DIGITALOUT_Off;
 00CE                   .dbline 76
 00CE           ;                       PWM8_1_WritePulseWidth(-pbchPulsweite);
 00CE 5203              mov A,[X+3]
 00D0 73                cpl A
 00D1 11FF              sub A,-1
 00D3 10                push X
 00D4 7C0000            xcall _PWM8_1_WritePulseWidth
 00D7 20                pop X
 00D8                   .dbline 77
 00D8           ;               }
 00D8           L12:
 00D8                   .dbline 80
 00D8           ;                               
 00D8           ;               // LCD Ansteuern 
 00D8           ;               LCD_1_Position(0,5);            
 00D8 10                push X
 00D9 5705              mov X,5
 00DB 5000              mov A,0
 00DD 7C0000            xcall _LCD_1_Position
 00E0 20                pop X
 00E1                   .dbline 81
 00E1           ;               LCD_1_PrString(rgchLCD);
 00E1 5A00              mov [__r1],X
 00E3 060005            add [__r1],5
 00E6 10                push X
 00E7 5100              mov A,[__r0]
 00E9 08                push A
 00EA 5100              mov A,[__r1]
 00EC 5C                mov X,A
 00ED 18                pop A
 00EE 7C0000            xcall _LCD_1_PrString
 00F1 20                pop X
 00F2                   .dbline 83
 00F2           ;       
 00F2           ;       };
 00F2           L4:
 00F2                   .dbline 47
 00F2 8F63              xjmp L3
 00F4           X0:
 00F4                   .dbline -2
 00F4           L1:
 00F4 38F2              add SP,-14
 00F6 20                pop X
 00F7                   .dbline 0 ; func end
 00F7 8FFF              jmp .
 00F9                   .dbsym l kochPeriodendauer 13 c
 00F9                   .dbsym l pdchEntfernung 12 c
 00F9                   .dbsym l kochKS 11 c
 00F9                   .dbsym l kochKP 10 c
 00F9                   .dbsym l rgchLCD 5 A[5:5]c
 00F9                   .dbsym l pbchSollwert 4 c
 00F9                   .dbsym l pbchPulsweite 3 c
 00F9                   .dbsym l hichBeschleunigungssumme 2 c
 00F9                   .dbsym l hichAusgangswert 1 c
 00F9                   .dbsym l pdchBechleunigung 0 c
 00F9                   .dbend
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL_DUALADC8_fIsDataAvailable:   .word _DUALADC8_fIsDataAvailable
