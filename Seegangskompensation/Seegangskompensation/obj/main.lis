                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           L2:
 0000 5465737400        .byte 'T,'e,'s,'t,0
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Lesky\Desktop\Dropbox\Studium\Bechlor\SOFTWA~1\neu\SEEGAN~1\SEEGAN~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ; kochPeriodendauer -> X+10
 0000           ;   pbchSollwert -> X+9
 0000           ;  pbchPulsweite -> X+8
 0000           ; pdchEntfernung -> X+7
 0000           ; pdchBechleunigung -> X+6
 0000           ;        rgchLCD -> X+1
 0000           ; hichAusgangswert -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 380B              add SP,11
 0004                   .dbline 14
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; // Programm: Seegangskompensation bei Krahnanlagen
 0004           ; // Version: 0.0.0.1
 0004           ; // Controler: CY8C27446-24PXI
 0004           ; // Variablenbenennung nach Apps Hungaryan
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; 
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 16
 0004           ;       // Difinition der Konstanten
 0004           ;       char kochPeriodendauer = 50;                                    // Periodendauer
 0004 560A32            mov [X+10],50
 0007                   .dbline 19
 0007           ;       // Variablendeklration
 0007           ;       
 0007           ;       char rgchLCD[] = "Test";                                                // Define RAM string
 0007 550000            mov [__r1],<L2
 000A 550000            mov [__r0],>L2
 000D 5A00              mov [__r3],X
 000F 060001            add [__r3],1
 0012 10                push X
 0013 550000            mov [__rX],0
 0016 5100              mov A,[__r0]
 0018 5800              mov X,[__r1]
 001A           X1:
 001A 08                push A
 001B 28                romx
 001C 3F00              mvi [__r3],A
 001E 18                pop A
 001F 75                inc X
 0020 0900              adc A,0
 0022 7600              inc [__rX]
 0024 3C0005            cmp [__rX],5
 0027 BFF2              jnz X1
 0029 20                pop X
 002A                   .dbline 26
 002A           ;       char pdchBechleunigung, pdchEntfernung;                 // Variablen zum Einlesen der Daten
 002A           ;       char pbchSollwert;                                                              
 002A           ;       char pbchPulsweite;
 002A           ;       char hichAusgangswert;                                                  
 002A           ;       // Initialisierung des Controlers
 002A           ;       
 002A           ;       M8C_EnableGInt;                                         // Enable global interrupts     
 002A 7101                      or  F, 01h
 002C           
 002C                   .dbline 28
 002C           ;       
 002C           ;       LCD_1_Start();                                                  // Initialisieren des LCD-Displays
 002C 10                push X
 002D 7C0000            xcall _LCD_1_Start
 0030 20                pop X
 0031                   .dbline 30
 0031           ;       
 0031           ;       PWM8_1_WritePeriod(kochPeriodendauer);                          // Initialisieren der PWM-Module                    
 0031 10                push X
 0032 520A              mov A,[X+10]
 0034 7C0000            xcall _PWM8_1_WritePeriod
 0037                   .dbline 31
 0037           ;     PWM8_1_Start();
 0037 7C0000            xcall _PWM8_1_Start
 003A 20                pop X
 003B                   .dbline 32
 003B           ;       PWM8_2_WritePeriod(kochPeriodendauer);                             
 003B 10                push X
 003C 520A              mov A,[X+10]
 003E 7C0000            xcall _PWM8_2_WritePeriod
 0041                   .dbline 33
 0041           ;     PWM8_2_Start();
 0041 7C0000            xcall _PWM8_2_Start
 0044                   .dbline 35
 0044           ; 
 0044           ;       DUALADC8_Start(DUALADC8_HIGHPOWER);                     // Initialisieren des Dualen AD-Wandlers
 0044 5003              mov A,3
 0046 7C0000            xcall _DUALADC8_Start
 0049                   .dbline 36
 0049           ;       DUALADC8_SetCalcTime(100);                              // f端r Entfernung und Beschleunigung
 0049 5700              mov X,0
 004B 5064              mov A,100
 004D 7C0000            xcall _DUALADC8_SetCalcTime
 0050                   .dbline 37
 0050           ;       DUALADC8_GetSamples(); 
 0050 7C0000            xcall _DUALADC8_GetSamples
 0053                   .dbline 39
 0053           ;       
 0053           ;       ADCINC_Start(ADCINC_HIGHPOWER);                         // Initialisieren des AD-Wandlers
 0053 5003              mov A,3
 0055 7C0000            xcall _ADCINC_Start
 0058                   .dbline 40
 0058           ;       ADCINC_GetSamples(0);                                   // f端r den Sollwert
 0058 5000              mov A,0
 005A 7C0000            xcall _ADCINC_GetSamples
 005D 20                pop X
 005E 8081              xjmp L4
 0060           L3:
 0060                   .dbline 43
 0060           ;               
 0060           ;       // Endlosschleife
 0060           ;       while(1) {
 0060                   .dbline 46
 0060           ;       
 0060           ;               // Daten Einlesen
 0060           ;               if(ADCINC_fIsDataAvailable() != 0)                      // Wenn Sollwertdaten bereit sind
 0060 10                push X
 0061 7C0000            xcall _ADCINC_fIsDataAvailable
 0064 20                pop X
 0065 3900              cmp A,0
 0067 A008              jz L9
 0069                   .dbline 47
 0069           ;               pbchSollwert = ADCINC_cClearFlagGetData();      // Einlesen des Sollwertes
 0069 10                push X
 006A 7C0000            xcall _ADCINC_cClearFlagGetData
 006D 20                pop X
 006E 5409              mov [X+9],A
 0070           L8:
 0070                   .dbline 50
 0070           ;                                                                       // data ready flag zur端vksetzen
 0070           ;                          
 0070           ;       while(DUALADC8_fIsDataAvailable == 0);                  // Auf Entfernung und Position Warten
 0070           L9:
 0070                   .dbline 50
 0070 5000              mov A,<PL_DUALADC8_fIsDataAvailable
 0072 10                push X
 0073 5800              mov X,[__r1]
 0075 08                push A
 0076 28                romx
 0077 5300              mov [__r0],A
 0079 18                pop A
 007A 75                inc X
 007B 0900              adc A,0
 007D 28                romx
 007E 20                pop X
 007F 3C0000            cmp [__r0],0
 0082 AFED              jz L8
 0084                   .dbline 51
 0084           ;               pdchBechleunigung = DUALADC8_cGetData1();       // Einlesen der Beschleunigung
 0084 10                push X
 0085 7C0000            xcall _DUALADC8_cGetData1
 0088 20                pop X
 0089 5406              mov [X+6],A
 008B                   .dbline 52
 008B           ;       pdchEntfernung = DUALADC8_cGetData2ClearFlag(); // Einlesen der Entfernung
 008B 10                push X
 008C 7C0000            xcall _DUALADC8_cGetData2ClearFlag
 008F 20                pop X
 0090 5407              mov [X+7],A
 0092                   .dbline 58
 0092           ;                                                                       // data ready flag zur端vksetzen                                    
 0092           ;               // Parameter Berechnen
 0092           ;               
 0092           ;               // Ausgang Setzen
 0092           ;               // positive Drehrichtung
 0092           ;               if (hichAusgangswert >= OSC_CR0){                               
 0092 7110              or F,0x10  ; iopage = 1
 0094 5DE0              mov A,REG[0xe0]
 0096 5300              mov [__r0],A
 0098 5200              mov A,[X+0]
 009A 70CF              and F,0xCF      ; iopage = 0
 009C 3A00              cmp A,[__r0]
 009E C00D              jc L11
 00A0           X2:
 00A0                   .dbline 59
 00A0           ;                       PWM8_1_WritePulseWidth(pbchPulsweite);
 00A0                   .dbline 59
 00A0 10                push X
 00A1 5208              mov A,[X+8]
 00A3 7C0000            xcall _PWM8_1_WritePulseWidth
 00A6                   .dbline 60
 00A6           ;                       PWM8_2_WritePulseWidth(0);
 00A6 5000              mov A,0
 00A8 7C0000            xcall _PWM8_2_WritePulseWidth
 00AB 20                pop X
 00AC                   .dbline 61
 00AC           ;               }
 00AC           L11:
 00AC                   .dbline 63
 00AC           ;               // negative Drehrichtung
 00AC           ;               if (hichAusgangswert >= OSC_CR0){                               
 00AC 7110              or F,0x10  ; iopage = 1
 00AE 5DE0              mov A,REG[0xe0]
 00B0 5300              mov [__r0],A
 00B2 5200              mov A,[X+0]
 00B4 70CF              and F,0xCF      ; iopage = 0
 00B6 3A00              cmp A,[__r0]
 00B8 C00D              jc L13
 00BA           X3:
 00BA                   .dbline 64
 00BA           ;                       PWM8_2_WritePulseWidth(pbchPulsweite);
 00BA                   .dbline 64
 00BA 10                push X
 00BB 5208              mov A,[X+8]
 00BD 7C0000            xcall _PWM8_2_WritePulseWidth
 00C0                   .dbline 65
 00C0           ;                       PWM8_1_WritePulseWidth(0);
 00C0 5000              mov A,0
 00C2 7C0000            xcall _PWM8_1_WritePulseWidth
 00C5 20                pop X
 00C6                   .dbline 66
 00C6           ;               }
 00C6           L13:
 00C6                   .dbline 70
 00C6           ;               
 00C6           ;               
 00C6           ;               // LCD Ansteuern 
 00C6           ;               LCD_1_Position(0,5);            
 00C6 10                push X
 00C7 5705              mov X,5
 00C9 5000              mov A,0
 00CB 7C0000            xcall _LCD_1_Position
 00CE 20                pop X
 00CF                   .dbline 71
 00CF           ;               LCD_1_PrString(rgchLCD);
 00CF 5A00              mov [__r1],X
 00D1 060001            add [__r1],1
 00D4 10                push X
 00D5 5100              mov A,[__r0]
 00D7 08                push A
 00D8 5100              mov A,[__r1]
 00DA 5C                mov X,A
 00DB 18                pop A
 00DC 7C0000            xcall _LCD_1_PrString
 00DF 20                pop X
 00E0                   .dbline 73
 00E0           ;       
 00E0           ;       };
 00E0           L4:
 00E0                   .dbline 43
 00E0 8F7F              xjmp L3
 00E2           X0:
 00E2                   .dbline -2
 00E2           L1:
 00E2 38F5              add SP,-11
 00E4 20                pop X
 00E5                   .dbline 0 ; func end
 00E5 8FFF              jmp .
 00E7                   .dbsym l kochPeriodendauer 10 c
 00E7                   .dbsym l pbchSollwert 9 c
 00E7                   .dbsym l pbchPulsweite 8 c
 00E7                   .dbsym l pdchEntfernung 7 c
 00E7                   .dbsym l pdchBechleunigung 6 c
 00E7                   .dbsym l rgchLCD 1 A[5:5]c
 00E7                   .dbsym l hichAusgangswert 0 c
 00E7                   .dbend
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL_DUALADC8_fIsDataAvailable:   .word _DUALADC8_fIsDataAvailable
