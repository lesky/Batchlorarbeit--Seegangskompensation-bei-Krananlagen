                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Lesky\Desktop\NEUERO~1\SEEGAN~1\SEEGAN~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ; hichBeschleunigungssumme -> X+4
 0000           ; hichAusgangswert -> X+3
 0000           ;         kochKS -> X+2
 0000           ;         kochKP -> X+1
 0000           ; kochPeriodendauer -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3805              add SP,5
 0004                   .dbline 52
 0004           ; /********************************************************
 0004           ; * C main-Funktion                                                                             *
 0004           ; * Programm: Seegangskompensation bei Krahnanlagen             *
 0004           ; * Controler: CY8C27446-24PXI                                                  *
 0004           ; *                                                                                                             *
 0004           ; * I/O-Konfiguration:                                                                  *
 0004           ; * LCD                         -> Port 2                                                               *
 0004           ; * Selbsttest  -> 1.1                                                                  *
 0004           ; * IN1                 -> 1.2                                                                  *
 0004           ; * IN2                 -> 1.3                                                                  *
 0004           ; * PWM 1                       -> 1.4                                                                  *
 0004           ; * Beschleunigung-> 0.1                                                                        *
 0004           ; * Entfernung  -> 0.4                                                                  *
 0004           ; * Sollwert            -> 0.5                                                                  *
 0004           ; *                                                                                                             *
 0004           ; * Zusätzlich definierte Prüfixe zur Variablenbenennung      *
 0004           ; * Mittels Ungaricher Notation nach Charles Simonyi:           *
 0004           ; * pd  -> Prozessbezogene Daten                                                *
 0004           ; * ko  -> Konstanten                                                                   *
 0004           ; * hi  -> Interne Hilfsgrößen                                                        *
 0004           ; * in  -> Datentyp Integer                                                             *
 0004           ; ********************************************************/
 0004           ; 
 0004           ; #include <m8c.h>        
 0004           ; #include "PSoCAPI.h"    
 0004           ; #include <stdlib.h>
 0004           ; 
 0004           ; // Präprozessor:Für testzwecke 
 0004           ; // #defein Test nicht auskomentieren:
 0004           ; #define TEST
 0004           ; 
 0004           ; // Funktionsprototypen:
 0004           ; void LCDansteuern(char);
 0004           ; void Dateneinlesen(void);
 0004           ; void Ausgangansteuern(char, char);
 0004           ; 
 0004           ; 
 0004           ; // Präprozessor: kompiliere Funktion nur wenn Test
 0004           ; #ifdef TEST
 0004           ;       void test(char);
 0004           ; #endif 
 0004           ; 
 0004           ; // globale Structur zur Übergabe der Prozessdaten:
 0004           ; struct 
 0004           ;    {                                                  
 0004           ;       char pdchBechleunigung, pdchEntfernung;                 
 0004           ;       char pdchSollwert;                                                              
 0004           ;       } prozess;
 0004           ; 
 0004           ; 
 0004           ; void main(void)
 0004           ;       {
 0004                   .dbline 59
 0004           ;       
 0004           ;       /********************************************************
 0004           ;       *                       Deffinitionen und Deklarationen                         *
 0004           ;       ********************************************************/       
 0004           ;               
 0004           ;       // Konstanten
 0004           ;       char kochPeriodendauer = 50;                                    
 0004 560032            mov [X+0],50
 0007                   .dbline 72
 0007           ;       char kochKP;
 0007           ;       char kochKS;
 0007           ;               
 0007           ;       // Variablen
 0007           ;       char hichAusgangswert;                                                  
 0007           ;       char hichBeschleunigungssumme;  
 0007           ;               
 0007           ;       /********************************************************
 0007           ;       *                       Initialisierung des Controllers                         *
 0007           ;       ********************************************************/
 0007           ;       
 0007           ;       //globale Interrupts Freigeben
 0007           ;       M8C_EnableGInt;                                                 
 0007 7101                      or  F, 01h
 0009           
 0009                   .dbline 75
 0009           ;       
 0009           ;       // Initialisieren des LCD-Displays
 0009           ;       LCD_1_Start();                                                  
 0009 10                push X
 000A 7C0000            xcall _LCD_1_Start
 000D                   .dbline 79
 000D           ;       
 000D           ;       // Initialisieren des PWM-Moduls
 000D           ;       // PWM8_1_WritePeriod(kochPeriodendauer);                                   
 000D           ;     PWM8_1_Start();
 000D 7C0000            xcall _PWM8_1_Start
 0010                   .dbline 81
 0010           ;       
 0010           ;       PGA_1_Start(PGA_1_LOWPOWER);
 0010 5001              mov A,1
 0012 7C0000            xcall _PGA_1_Start
 0015                   .dbline 82
 0015           ;       PGA_2_Start(PGA_2_LOWPOWER);
 0015 5001              mov A,1
 0017 7C0000            xcall _PGA_2_Start
 001A                   .dbline 83
 001A           ;       PGA_3_Start(PGA_3_LOWPOWER);    
 001A 5001              mov A,1
 001C 7C0000            xcall _PGA_3_Start
 001F                   .dbline 87
 001F           ;       
 001F           ;       // Initialisieren des Dualen AD-Wandlers
 001F           ;       // für Entfernung und Beschleunigung
 001F           ;       DUALADC8_Start(DUALADC8_HIGHPOWER);                                             
 001F 5003              mov A,3
 0021 7C0000            xcall _DUALADC8_Start
 0024                   .dbline 88
 0024           ;       DUALADC8_GetSamples(); 
 0024 7C0000            xcall _DUALADC8_GetSamples
 0027                   .dbline 92
 0027           ;       
 0027           ;       // Initialisieren des AD-Wandlers
 0027           ;       // für den Sollwert
 0027           ;       ADCINC_Start(ADCINC_HIGHPOWER);                         
 0027 5003              mov A,3
 0029 7C0000            xcall _ADCINC_Start
 002C                   .dbline 93
 002C           ;       ADCINC_GetSamples(0);                                   
 002C 5000              mov A,0
 002E 7C0000            xcall _ADCINC_GetSamples
 0031                   .dbline 96
 0031           ;       
 0031           ;       //Initialisieren der Digitalen Ausgänge
 0031           ;       IN1_Start();    
 0031 7C0000            xcall _IN1_Start
 0034                   .dbline 97
 0034           ;       IN2_Start();
 0034 7C0000            xcall _IN2_Start
 0037                   .dbline 98
 0037           ;       SELBSTTEST_Start();
 0037 7C0000            xcall _SELBSTTEST_Start
 003A                   .dbline 140
 003A           ;       
 003A           ;       // Präprozessor: kompiliere whileschleife wenn kein test
 003A           ;       #ifndef TEST
 003A           ;               
 003A           ;               /********************************************************
 003A           ;               *                       Endlosschleife für Dauerbetrieb                                *
 003A           ;               ********************************************************/
 003A           ; 
 003A           ;               while(1) 
 003A           ;                       {
 003A           ;                       // Daten Einlesen
 003A           ;                       
 003A           ;                       Dateneinlesen();
 003A           ;                                                
 003A           ;                       // Parameter Berechnen
 003A           ;                       
 003A           ;                       hichBeschleunigungssumme = hichBeschleunigungssumme + prozess.pdchBechleunigung;
 003A           ;                       
 003A           ;                       hichAusgangswert = ( prozess.pdchSollwert - prozess.pdchBechleunigung ) * kochKP
 003A           ;                                                               - 1 / kochKS * hichBeschleunigungssumme;
 003A           ;                       
 003A           ;                       // Daten Ausgeben:
 003A           ;                               
 003A           ;                       Ausgangansteuern(hichAusgangswert);
 003A           ;                       
 003A           ;                       LCDansteuern(prozess.pdchEntfernung);
 003A           ; 
 003A           ;                               
 003A           ;                       };
 003A           ;                       
 003A           ;       /********************************************************
 003A           ;       * Achtung die Folgenden Zeilen dienen nur zu Testzwecken*
 003A           ;       * und sind für das Fertige Programm nicht relevant.            *
 003A           ;       * Sie werden anstelle der Regulären while Schleife             *
 003A           ;       * Kompiliert, wenn die Bedingung #ifndef TEST nicht     *
 003A           ;       * erfüllt ist.                                                                                 *
 003A           ;       ********************************************************/
 003A           ; 
 003A           ;       #else
 003A           ;               
 003A           ;               // Selbsttest des Beshleunigungssensoers anschalten
 003A           ;               SELBSTTEST_Switch(1);
 003A 5001              mov A,1
 003C 7C0000            xcall _SELBSTTEST_Switch
 003F 20                pop X
 0040 8012              xjmp L4
 0042           L3:
 0042                   .dbline 145
 0042           ;                       
 0042           ;               // whileschleife zu testzwecken
 0042           ;               // Konstante zur verweildauer in der schleife
 0042           ;               while (1)
 0042           ;                       {
 0042                   .dbline 146
 0042           ;                               Dateneinlesen();
 0042 9051              xcall _Dateneinlesen
 0044                   .dbline 147
 0044           ;                               Ausgangansteuern(10, 1);
 0044 5001              mov A,1
 0046 08                push A
 0047 500A              mov A,10
 0049 08                push A
 004A 907C              xcall _Ausgangansteuern
 004C                   .dbline 150
 004C           ;                               
 004C           ;                               // Testfunktionen Aufrufen:
 004C           ;                                test(prozess.pdchBechleunigung);
 004C 5100              mov A,[_prozess]
 004E 08                push A
 004F 913B              xcall _test
 0051 38FD              add SP,-3
 0053                   .dbline 154
 0053           ;                               // test(prozess.pdchEntfernung);
 0053           ;                               // test(prozess.pdchSollwert);
 0053           ;                               
 0053           ;                       };
 0053           L4:
 0053                   .dbline 144
 0053 8FEE              xjmp L3
 0055           X0:
 0055                   .dbline -2
 0055           L2:
 0055 38FB              add SP,-5
 0057 20                pop X
 0058                   .dbline 0 ; func end
 0058 8FFF              jmp .
 005A                   .dbsym l hichBeschleunigungssumme 4 c
 005A                   .dbsym l hichAusgangswert 3 c
 005A                   .dbsym l kochKS 2 c
 005A                   .dbsym l kochKP 1 c
 005A                   .dbsym l kochPeriodendauer 0 c
 005A                   .dbend
 005A                   .dbfunc e LCDansteuern _LCDansteuern fV
 005A           ;           rgch -> X+0
 005A           ;       hichdata -> X-4
 005A           _LCDansteuern::
 005A                   .dbline -1
 005A 10                push X
 005B 4F                mov X,SP
 005C 3805              add SP,5
 005E                   .dbline 165
 005E           ;                       
 005E           ;       // Präprozessor: Ende der Verzweifung
 005E           ;       #endif 
 005E           ; }
 005E           ;       
 005E           ; /********************************************************
 005E           ; *                     Funktionsdeklarationen                                          *
 005E           ; ********************************************************/
 005E           ;       
 005E           ; void LCDansteuern(char hichdata)
 005E           ;       {               
 005E                   .dbline 168
 005E           ;                       char rgch[5];
 005E           ;                       // Text auf LCD ausgeben
 005E           ;                       LCD_1_Position(0,5);    
 005E 10                push X
 005F 5705              mov X,5
 0061 5000              mov A,0
 0063 7C0000            xcall _LCD_1_Position
 0066                   .dbline 169
 0066           ;                       LCD_1_PrCString("Wert:");
 0066 5000              mov A,>L7
 0068 08                push A
 0069 5000              mov A,<L7
 006B 5C                mov X,A
 006C 18                pop A
 006D 7C0000            xcall _LCD_1_PrCString
 0070 20                pop X
 0071                   .dbline 172
 0071           ;                       
 0071           ;                       // Zahl Auf LCD ausgeben
 0071           ;                       itoa(rgch,hichdata,10);
 0071 5000              mov A,0
 0073 08                push A
 0074 500A              mov A,10
 0076 08                push A
 0077 52FC              mov A,[X-4]
 0079 5300              mov [__r1],A
 007B 5000              mov A,0
 007D 08                push A
 007E 5100              mov A,[__r1]
 0080 08                push A
 0081 5000              mov A,0
 0083 08                push A
 0084 10                push X
 0085 7C0000            xcall _itoa
 0088 38FA              add SP,-6
 008A                   .dbline 173
 008A           ;                       LCD_1_PrString(rgch);           
 008A 10                push X
 008B 5100              mov A,[__r0]
 008D 7C0000            xcall _LCD_1_PrString
 0090 20                pop X
 0091                   .dbline -2
 0091           L6:
 0091 38FB              add SP,-5
 0093 20                pop X
 0094                   .dbline 0 ; func end
 0094 7F                ret
 0095                   .dbsym l rgch 0 A[5:5]c
 0095                   .dbsym l hichdata -4 c
 0095                   .dbend
 0095                   .dbfunc e Dateneinlesen _Dateneinlesen fV
 0095           _Dateneinlesen::
 0095                   .dbline -1
 0095                   .dbline 178
 0095           ; 
 0095           ;       }
 0095           ;       
 0095           ; void Dateneinlesen(void)
 0095           ;       {       
 0095                   .dbline 180
 0095           ;       // Wenn Sollwertdaten bereit sind
 0095           ;       if(ADCINC_fIsDataAvailable() != 0)
 0095 10                push X
 0096 7C0000            xcall _ADCINC_fIsDataAvailable
 0099 20                pop X
 009A 3900              cmp A,0
 009C A008              jz L13
 009E                   .dbline 184
 009E           ;                       
 009E           ;               // Einlesen des Sollwertes
 009E           ;               // data ready flag zurüvksetzen        
 009E           ;               prozess.pdchSollwert = ADCINC_cClearFlagGetData();              
 009E 10                push X
 009F 7C0000            xcall _ADCINC_cClearFlagGetData
 00A2 20                pop X
 00A3 5302              mov [_prozess+2],A
 00A5           L12:
 00A5                   .dbline 187
 00A5           ;                          
 00A5           ;       // Auf Entfernung und Position Warten
 00A5           ;               while(DUALADC8_fIsDataAvailable == 0);                  
 00A5           L13:
 00A5                   .dbline 187
 00A5 5000              mov A,<PL_DUALADC8_fIsDataAvailable
 00A7 10                push X
 00A8 5800              mov X,[__r1]
 00AA 08                push A
 00AB 28                romx
 00AC 5300              mov [__r0],A
 00AE 18                pop A
 00AF 75                inc X
 00B0 0900              adc A,0
 00B2 28                romx
 00B3 20                pop X
 00B4 3C0000            cmp [__r0],0
 00B7 AFED              jz L12
 00B9                   .dbline 189
 00B9           ;               // Einlesen der Beschleunigung
 00B9           ;               prozess.pdchBechleunigung = DUALADC8_cGetData1();       
 00B9 10                push X
 00BA 7C0000            xcall _DUALADC8_cGetData1
 00BD 20                pop X
 00BE 5300              mov [_prozess],A
 00C0                   .dbline 193
 00C0           ;       
 00C0           ;               // Einlesen der Entfernung
 00C0           ;         // data ready flag zurüvksetzen         
 00C0           ;               prozess.pdchEntfernung = DUALADC8_cGetData2ClearFlag();         
 00C0 10                push X
 00C1 7C0000            xcall _DUALADC8_cGetData2ClearFlag
 00C4 20                pop X
 00C5 5301              mov [_prozess+1],A
 00C7                   .dbline -2
 00C7           L8:
 00C7                   .dbline 0 ; func end
 00C7 7F                ret
 00C8                   .dbend
 00C8                   .dbfunc e Ausgangansteuern _Ausgangansteuern fV
 00C8           ; kochKorekturfaktor -> X+2
 00C8           ;            iin -> X+0
 00C8           ;   hichRichtung -> X-5
 00C8           ; hichAusgangswert -> X-4
 00C8           _Ausgangansteuern::
 00C8                   .dbline -1
 00C8 10                push X
 00C9 4F                mov X,SP
 00CA 3803              add SP,3
 00CC                   .dbline 197
 00CC           ;       }
 00CC           ; 
 00CC           ; void Ausgangansteuern(char hichAusgangswert, char hichRichtung)
 00CC           ;       {
 00CC                   .dbline 201
 00CC           ;               int iin;
 00CC           ;               // Korekturfaktor zur 
 00CC           ;               // bestimmung der Pulsweite:
 00CC           ;               char kochKorekturfaktor = 1;
 00CC 560201            mov [X+2],1
 00CF                   .dbline 215
 00CF           ;               
 00CF           ; //            // Bremsen durch Leerlauf
 00CF           ; //            if (hichRichtung == 0){                         
 00CF           ; //                    // Ausgänge ansteuern
 00CF           ; //                    IN1_Switch(0);
 00CF           ; //                    IN2_Switch(0);
 00CF           ; //                    PWM8_1_Stop();
 00CF           ; //                    PWM8_1_WritePulseWidth(255);
 00CF           ; //                    PWM8_1_Start();
 00CF           ; //                    }
 00CF           ;               
 00CF           ;               // Seil Abwickeln 
 00CF           ;               
 00CF           ;               if (hichRichtung == 1){
 00CF 3DFB01            cmp [X-5],1
 00D2 B04D              jnz L17
 00D4                   .dbline 221
 00D4           ;               //if (hichAusgangswert > 0){
 00D4           ;                       
 00D4           ;                       //wenn sich die Drehrichtung ändert:
 00D4           ;                       //vorher 100 mal Bremsen
 00D4           ;                       
 00D4           ;                       if (IN2_GetState() == 1){
 00D4                   .dbline 221
 00D4 10                push X
 00D5 7C0000            xcall _IN2_GetState
 00D8 20                pop X
 00D9 3901              cmp A,1
 00DB B020              jnz L19
 00DD                   .dbline 222
 00DD           ;                               for (iin = 0; iin < 100; iin ++)
 00DD                   .dbline 222
 00DD 560100            mov [X+1],0
 00E0 560000            mov [X+0],0
 00E3           L21:
 00E3                   .dbline 223
 00E3           ;                                       {
 00E3                   .dbline 224
 00E3           ;                                               Ausgangansteuern(0, 0);
 00E3 5000              mov A,0
 00E5 08                push A
 00E6 08                push A
 00E7 9FDF              xcall _Ausgangansteuern
 00E9 38FE              add SP,-2
 00EB                   .dbline 225
 00EB           ;                                       }
 00EB           L22:
 00EB                   .dbline 222
 00EB 7701              inc [X+1]
 00ED 0F0000            adc [X+0],0
 00F0                   .dbline 222
 00F0 5201              mov A,[X+1]
 00F2 1164              sub A,100
 00F4 5200              mov A,[X+0]
 00F6 3180              xor A,-128
 00F8 1980              sbb A,(0 ^ 0x80)
 00FA CFE8              jc L21
 00FC           X1:
 00FC                   .dbline 227
 00FC           ;                               
 00FC           ;                       }
 00FC           L19:
 00FC                   .dbline 229
 00FC           ;                       // Ausgänge ansteuern
 00FC           ;                       IN1_Switch(1);
 00FC 10                push X
 00FD 5001              mov A,1
 00FF 7C0000            xcall _IN1_Switch
 0102                   .dbline 230
 0102           ;                       IN2_Switch(0);
 0102 5000              mov A,0
 0104 7C0000            xcall _IN2_Switch
 0107                   .dbline 231
 0107           ;                       PWM8_1_Stop();
 0107 7C0000            xcall _PWM8_1_Stop
 010A 20                pop X
 010B                   .dbline 232
 010B           ;                       PWM8_1_WritePulseWidth(hichAusgangswert * kochKorekturfaktor);
 010B 5202              mov A,[X+2]
 010D 60E8              mov REG[0xe8],A
 010F 52FC              mov A,[X-4]
 0111 60E9              mov REG[0xe9],A
 0113 40                nop
 0114 5DEB              mov A,REG[0xeb]
 0116 10                push X
 0117 7C0000            xcall _PWM8_1_WritePulseWidth
 011A                   .dbline 233
 011A           ;                       PWM8_1_Start();
 011A 7C0000            xcall _PWM8_1_Start
 011D 20                pop X
 011E                   .dbline 234
 011E           ;               }
 011E 8069              xjmp L18
 0120           L17:
 0120                   .dbline 238
 0120           ;               
 0120           ;               // Seil Aufwickeln
 0120           ;               
 0120           ;               else if (hichRichtung == 2){
 0120 3DFB02            cmp [X-5],2
 0123 B04D              jnz L25
 0125                   .dbline 243
 0125           ;               //else if (hichAusgangswert < 0){
 0125           ;                       
 0125           ;                       //wenn sich die Drehrichtung ändert:
 0125           ;                       //vorher 100 mal Bremsen
 0125           ;                       if (IN1_GetState() == 1){
 0125                   .dbline 243
 0125 10                push X
 0126 7C0000            xcall _IN1_GetState
 0129 20                pop X
 012A 3901              cmp A,1
 012C B020              jnz L27
 012E                   .dbline 244
 012E           ;                       for (iin = 0; iin < 100; iin ++)
 012E                   .dbline 244
 012E 560100            mov [X+1],0
 0131 560000            mov [X+0],0
 0134           L29:
 0134                   .dbline 245
 0134           ;                                       {
 0134                   .dbline 246
 0134           ;                                               Ausgangansteuern(0, 0);
 0134 5000              mov A,0
 0136 08                push A
 0137 08                push A
 0138 9F8E              xcall _Ausgangansteuern
 013A 38FE              add SP,-2
 013C                   .dbline 247
 013C           ;                                       }
 013C           L30:
 013C                   .dbline 244
 013C 7701              inc [X+1]
 013E 0F0000            adc [X+0],0
 0141                   .dbline 244
 0141 5201              mov A,[X+1]
 0143 1164              sub A,100
 0145 5200              mov A,[X+0]
 0147 3180              xor A,-128
 0149 1980              sbb A,(0 ^ 0x80)
 014B CFE8              jc L29
 014D           X2:
 014D                   .dbline 249
 014D           ;                                       
 014D           ;                       } 
 014D           L27:
 014D                   .dbline 252
 014D           ;                       // Klammer zu Fiel Warum
 014D           ;                       // Ausgänge ansteuern
 014D           ;                       IN1_Switch(0);
 014D 10                push X
 014E 5000              mov A,0
 0150 7C0000            xcall _IN1_Switch
 0153                   .dbline 253
 0153           ;                       IN2_Switch(1);
 0153 5001              mov A,1
 0155 7C0000            xcall _IN2_Switch
 0158                   .dbline 254
 0158           ;                       PWM8_1_Stop();
 0158 7C0000            xcall _PWM8_1_Stop
 015B 20                pop X
 015C                   .dbline 255
 015C           ;                       PWM8_1_WritePulseWidth(hichAusgangswert * kochKorekturfaktor);
 015C 5202              mov A,[X+2]
 015E 60E8              mov REG[0xe8],A
 0160 52FC              mov A,[X-4]
 0162 60E9              mov REG[0xe9],A
 0164 40                nop
 0165 5DEB              mov A,REG[0xeb]
 0167 10                push X
 0168 7C0000            xcall _PWM8_1_WritePulseWidth
 016B                   .dbline 256
 016B           ;                       PWM8_1_Start();
 016B 7C0000            xcall _PWM8_1_Start
 016E 20                pop X
 016F                   .dbline 257
 016F           ;                       }
 016F 8018              xjmp L26
 0171           L25:
 0171                   .dbline 260
 0171           ;       
 0171           ;               // Bremsen durch Leerlauf
 0171           ;               else {                          
 0171                   .dbline 262
 0171           ;                       // Ausgänge ansteuern
 0171           ;                       IN1_Switch(1);
 0171 10                push X
 0172 5001              mov A,1
 0174 7C0000            xcall _IN1_Switch
 0177                   .dbline 263
 0177           ;                       IN2_Switch(1);
 0177 5001              mov A,1
 0179 7C0000            xcall _IN2_Switch
 017C                   .dbline 264
 017C           ;                       PWM8_1_Stop();
 017C 7C0000            xcall _PWM8_1_Stop
 017F                   .dbline 265
 017F           ;                       PWM8_1_WritePulseWidth(0);
 017F 5000              mov A,0
 0181 7C0000            xcall _PWM8_1_WritePulseWidth
 0184                   .dbline 266
 0184           ;                       PWM8_1_Start();
 0184 7C0000            xcall _PWM8_1_Start
 0187 20                pop X
 0188                   .dbline 267
 0188           ;                       }
 0188           L26:
 0188           L18:
 0188                   .dbline -2
 0188           L16:
 0188 38FD              add SP,-3
 018A 20                pop X
 018B                   .dbline 0 ; func end
 018B 7F                ret
 018C                   .dbsym l kochKorekturfaktor 2 c
 018C                   .dbsym l iin 0 I
 018C                   .dbsym l hichRichtung -5 c
 018C                   .dbsym l hichAusgangswert -4 c
 018C                   .dbend
 018C                   .dbfunc e test _test fV
 018C           ;            iin -> X+0
 018C           ;       hichdata -> X-4
 018C           _test::
 018C                   .dbline -1
 018C 10                push X
 018D 4F                mov X,SP
 018E 3802              add SP,2
 0190                   .dbline 276
 0190           ;               
 0190           ;       }
 0190           ;       
 0190           ;       
 0190           ; // Präprozessor: kompiliere Funktion nur wenn Test
 0190           ; #ifdef TEST
 0190           ;       // Ausgabe der Testdaten auf LCD-Display
 0190           ;       void test(char hichdata)
 0190           ;               {
 0190                   .dbline 279
 0190           ;               // gibt 99999 mal LCD Aus
 0190           ;               int iin;
 0190           ;               for (iin = 0; iin <= 500; iin ++)
 0190 560100            mov [X+1],0
 0193 560000            mov [X+0],0
 0196           L34:
 0196                   .dbline 280
 0196           ;                       {
 0196                   .dbline 281
 0196           ;                       LCDansteuern(hichdata); 
 0196 52FC              mov A,[X-4]
 0198 08                push A
 0199 9EBF              xcall _LCDansteuern
 019B 38FF              add SP,-1
 019D                   .dbline 282
 019D           ;                       }
 019D           L35:
 019D                   .dbline 279
 019D 7701              inc [X+1]
 019F 0F0000            adc [X+0],0
 01A2                   .dbline 279
 01A2 50F4              mov A,-12
 01A4 1301              sub A,[X+1]
 01A6 5200              mov A,[X+0]
 01A8 3180              xor A,-128
 01AA 5300              mov [__rX],A
 01AC 5081              mov A,(1 ^ 0x80)
 01AE 1A00              sbb A,[__rX]
 01B0 DFE5              jnc L34
 01B2           X3:
 01B2                   .dbline -2
 01B2           L33:
 01B2 38FE              add SP,-2
 01B4 20                pop X
 01B5                   .dbline 0 ; func end
 01B5 7F                ret
 01B6                   .dbsym l iin 0 I
 01B6                   .dbsym l hichdata -4 c
 01B6                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile C:\Users\Lesky\Desktop\NEUERO~1\SEEGAN~1\SEEGAN~1\main.c
 0000           _prozess::
 0000                   .blkb 3
 0003                   .dbstruct 0 3 .1
 0003                   .dbfield 0 pdchBechleunigung c
 0003                   .dbfield 1 pdchEntfernung c
 0003                   .dbfield 2 pdchSollwert c
 0003                   .dbend
 0003                   .dbsym e prozess _prozess S[.1]
                        .area lit(rom, con, rel, lit)
 0000           L7:
 0000 576572743A00      .byte 'W,'e,'r,'t,58,0
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL_DUALADC8_fIsDataAvailable:   .word _DUALADC8_fIsDataAvailable
