                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Lesky\Desktop\NEUERO~1\SEEGAN~1\SEEGAN~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ; hichBeschleunigungssumme -> X+3
 0000           ; hichAusgangswert -> X+2
 0000           ;         kochKS -> X+1
 0000           ;         kochKP -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3804              add SP,4
 0004                   .dbline 52
 0004           ; /********************************************************
 0004           ; * C main-Funktion                                                                             *
 0004           ; * Programm: Seegangskompensation bei Krahnanlagen             *
 0004           ; * Controler: CY8C27446-24PXI                                                  *
 0004           ; *                                                                                                             *
 0004           ; * I/O-Konfiguration:                                                                  *
 0004           ; * LCD                         -> Port 2                                                               *
 0004           ; * Selbsttest  -> 1.1                                                                  *
 0004           ; * IN1                 -> 1.2                                                                  *
 0004           ; * IN2                 -> 1.3                                                                  *
 0004           ; * PWM 1                       -> 1.4                                                                  *
 0004           ; * Beschleunigung-> 0.1                                                                        *
 0004           ; * Entfernung  -> 0.4                                                                  *
 0004           ; * Sollwert            -> 0.5                                                                  *
 0004           ; *                                                                                                             *
 0004           ; * Zusätzlich definierte Prüfixe zur Variablenbenennung      *
 0004           ; * Mittels Ungaricher Notation nach Charles Simonyi:           *
 0004           ; * pd  -> Prozessbezogene Daten                                                *
 0004           ; * ko  -> Konstanten                                                                   *
 0004           ; * hi  -> Interne Hilfsgrößen                                                        *
 0004           ; * in  -> Datentyp Integer                                                             *
 0004           ; ********************************************************/
 0004           ; 
 0004           ; #include <m8c.h>        
 0004           ; #include "PSoCAPI.h"    
 0004           ; #include <stdlib.h>
 0004           ; 
 0004           ; // Präprozessor:Für testzwecke 
 0004           ; // #defein Test nicht auskomentieren:
 0004           ; #define TEST
 0004           ; 
 0004           ; // Funktionsprototypen:
 0004           ; void LCDansteuern(char);
 0004           ; void Dateneinlesen(void);
 0004           ; void Ausgangansteuern(char, char);
 0004           ; 
 0004           ; 
 0004           ; // Präprozessor: kompiliere Funktion nur wenn Test
 0004           ; #ifdef TEST
 0004           ;       void test(char);
 0004           ; #endif 
 0004           ; 
 0004           ; // globale Structur zur Übergabe der Prozessdaten:
 0004           ; struct 
 0004           ;    {                                                  
 0004           ;       char pdchBechleunigung, pdchEntfernung;                 
 0004           ;       char pdchSollwert;                                                              
 0004           ;       } prozess;
 0004           ; 
 0004           ; 
 0004           ; void main(void)
 0004           ;       {
 0004                   .dbline 71
 0004           ;       
 0004           ;       /********************************************************
 0004           ;       *                       Deffinitionen und Deklarationen                         *
 0004           ;       ********************************************************/       
 0004           ;               
 0004           ;       // Konstanten                                   
 0004           ;       char kochKP;
 0004           ;       char kochKS;
 0004           ;               
 0004           ;       // Variablen
 0004           ;       char hichAusgangswert;                                                  
 0004           ;       char hichBeschleunigungssumme;  
 0004           ;               
 0004           ;       /********************************************************
 0004           ;       *                       Initialisierung des Controllers                         *
 0004           ;       ********************************************************/
 0004           ;       
 0004           ;       //globale Interrupts Freigeben
 0004           ;       M8C_EnableGInt;                                                 
 0004 7101                      or  F, 01h
 0006           
 0006                   .dbline 74
 0006           ;       
 0006           ;       // Initialisieren des LCD-Displays
 0006           ;       LCD_1_Start();                                                  
 0006 10                push X
 0007 7C0000            xcall _LCD_1_Start
 000A                   .dbline 78
 000A           ;       
 000A           ;       // Initialisieren des PWM-Moduls
 000A           ;       // PWM8_1_WritePeriod(kochPeriodendauer);                                   
 000A           ;     PWM8_1_Start();
 000A 7C0000            xcall _PWM8_1_Start
 000D                   .dbline 80
 000D           ;       
 000D           ;       PGA_1_Start(PGA_1_LOWPOWER);
 000D 5001              mov A,1
 000F 7C0000            xcall _PGA_1_Start
 0012                   .dbline 81
 0012           ;       PGA_2_Start(PGA_2_LOWPOWER);
 0012 5001              mov A,1
 0014 7C0000            xcall _PGA_2_Start
 0017                   .dbline 82
 0017           ;       PGA_3_Start(PGA_3_LOWPOWER);    
 0017 5001              mov A,1
 0019 7C0000            xcall _PGA_3_Start
 001C                   .dbline 86
 001C           ;       
 001C           ;       // Initialisieren des Dualen AD-Wandlers
 001C           ;       // für Entfernung und Beschleunigung
 001C           ;       DUALADC8_Start(DUALADC8_HIGHPOWER);                                             
 001C 5003              mov A,3
 001E 7C0000            xcall _DUALADC8_Start
 0021                   .dbline 87
 0021           ;       DUALADC8_GetSamples(); 
 0021 7C0000            xcall _DUALADC8_GetSamples
 0024                   .dbline 91
 0024           ;       
 0024           ;       // Initialisieren des AD-Wandlers
 0024           ;       // für den Sollwert
 0024           ;       ADCINC_Start(ADCINC_HIGHPOWER);                         
 0024 5003              mov A,3
 0026 7C0000            xcall _ADCINC_Start
 0029                   .dbline 92
 0029           ;       ADCINC_GetSamples(0);                                   
 0029 5000              mov A,0
 002B 7C0000            xcall _ADCINC_GetSamples
 002E                   .dbline 95
 002E           ;       
 002E           ;       //Initialisieren der Digitalen Ausgänge
 002E           ;       IN1_Start();    
 002E 7C0000            xcall _IN1_Start
 0031                   .dbline 96
 0031           ;       IN2_Start();
 0031 7C0000            xcall _IN2_Start
 0034                   .dbline 97
 0034           ;       SELBSTTEST_Start();
 0034 7C0000            xcall _SELBSTTEST_Start
 0037                   .dbline 139
 0037           ;       
 0037           ;       // Präprozessor: kompiliere whileschleife wenn kein test
 0037           ;       #ifndef TEST
 0037           ;               
 0037           ;               /********************************************************
 0037           ;               *                       Endlosschleife für Dauerbetrieb                                *
 0037           ;               ********************************************************/
 0037           ; 
 0037           ;               while(1) 
 0037           ;                       {
 0037           ;                       // Daten Einlesen
 0037           ;                       
 0037           ;                       Dateneinlesen();
 0037           ;                                                
 0037           ;                       // Parameter Berechnen
 0037           ;                       
 0037           ;                       hichBeschleunigungssumme = hichBeschleunigungssumme + prozess.pdchBechleunigung;
 0037           ;                       
 0037           ;                       hichAusgangswert = ( prozess.pdchSollwert - prozess.pdchBechleunigung ) * kochKP
 0037           ;                                                               - 1 / kochKS * hichBeschleunigungssumme;
 0037           ;                       
 0037           ;                       // Daten Ausgeben:
 0037           ;                               
 0037           ;                       Ausgangansteuern(hichAusgangswert);
 0037           ;                       
 0037           ;                       LCDansteuern(prozess.pdchEntfernung);
 0037           ; 
 0037           ;                               
 0037           ;                       };
 0037           ;                       
 0037           ;       /********************************************************
 0037           ;       * Achtung die Folgenden Zeilen dienen nur zu Testzwecken*
 0037           ;       * und sind für das Fertige Programm nicht relevant.            *
 0037           ;       * Sie werden anstelle der Regulären while Schleife             *
 0037           ;       * Kompiliert, wenn die Bedingung #ifndef TEST nicht     *
 0037           ;       * erfüllt ist.                                                                                 *
 0037           ;       ********************************************************/
 0037           ; 
 0037           ;       #else
 0037           ;               
 0037           ;               // Selbsttest des Beshleunigungssensoers anschalten
 0037           ;               SELBSTTEST_Switch(1);
 0037 5001              mov A,1
 0039 7C0000            xcall _SELBSTTEST_Switch
 003C 20                pop X
 003D 801C              xjmp L4
 003F           L3:
 003F                   .dbline 144
 003F           ;                       
 003F           ;               // whileschleife zu testzwecken
 003F           ;               // Konstante zur verweildauer in der schleife
 003F           ;               while (1)
 003F           ;                       {
 003F                   .dbline 145
 003F           ;                               Dateneinlesen();
 003F 905B              xcall _Dateneinlesen
 0041                   .dbline 146
 0041           ;                               Ausgangansteuern(255, 2);
 0041 5002              mov A,2
 0043 08                push A
 0044 50FF              mov A,-1
 0046 08                push A
 0047 9086              xcall _Ausgangansteuern
 0049 38FE              add SP,-2
 004B                   .dbline 147
 004B           ;                               Ausgangansteuern(255, 1);
 004B 5001              mov A,1
 004D 08                push A
 004E 50FF              mov A,-1
 0050 08                push A
 0051 907C              xcall _Ausgangansteuern
 0053                   .dbline 149
 0053           ;                               // Testfunktionen Aufrufen:
 0053           ;                                test(prozess.pdchBechleunigung);
 0053 5100              mov A,[_prozess]
 0055 08                push A
 0056 9118              xcall _test
 0058 38FD              add SP,-3
 005A                   .dbline 153
 005A           ;                               // test(prozess.pdchEntfernung);
 005A           ;                               // test(prozess.pdchSollwert);
 005A           ;                               
 005A           ;                       };
 005A           L4:
 005A                   .dbline 143
 005A 8FE4              xjmp L3
 005C           X0:
 005C                   .dbline -2
 005C           L2:
 005C 38FC              add SP,-4
 005E 20                pop X
 005F                   .dbline 0 ; func end
 005F 8FFF              jmp .
 0061                   .dbsym l hichBeschleunigungssumme 3 c
 0061                   .dbsym l hichAusgangswert 2 c
 0061                   .dbsym l kochKS 1 c
 0061                   .dbsym l kochKP 0 c
 0061                   .dbend
 0061                   .dbfunc e LCDansteuern _LCDansteuern fV
 0061           ;           rgch -> X+0
 0061           ;       hichdata -> X-4
 0061           _LCDansteuern::
 0061                   .dbline -1
 0061 10                push X
 0062 4F                mov X,SP
 0063 3805              add SP,5
 0065                   .dbline 164
 0065           ;                       
 0065           ;       // Präprozessor: Ende der Verzweifung
 0065           ;       #endif 
 0065           ; }
 0065           ;       
 0065           ; /********************************************************
 0065           ; *                     Funktionsdeklarationen                                          *
 0065           ; ********************************************************/
 0065           ;       
 0065           ; void LCDansteuern(char hichdata)
 0065           ;       {               
 0065                   .dbline 167
 0065           ;                       char rgch[5];
 0065           ;                       // Text auf LCD ausgeben
 0065           ;                       LCD_1_Position(0,5);    
 0065 10                push X
 0066 5705              mov X,5
 0068 5000              mov A,0
 006A 7C0000            xcall _LCD_1_Position
 006D                   .dbline 168
 006D           ;                       LCD_1_PrCString("Wert:");
 006D 5000              mov A,>L7
 006F 08                push A
 0070 5000              mov A,<L7
 0072 5C                mov X,A
 0073 18                pop A
 0074 7C0000            xcall _LCD_1_PrCString
 0077 20                pop X
 0078                   .dbline 171
 0078           ;                       
 0078           ;                       // Zahl Auf LCD ausgeben
 0078           ;                       itoa(rgch,hichdata,10);
 0078 5000              mov A,0
 007A 08                push A
 007B 500A              mov A,10
 007D 08                push A
 007E 52FC              mov A,[X-4]
 0080 5300              mov [__r1],A
 0082 5000              mov A,0
 0084 08                push A
 0085 5100              mov A,[__r1]
 0087 08                push A
 0088 5000              mov A,0
 008A 08                push A
 008B 10                push X
 008C 7C0000            xcall _itoa
 008F 38FA              add SP,-6
 0091                   .dbline 172
 0091           ;                       LCD_1_PrString(rgch);           
 0091 10                push X
 0092 5100              mov A,[__r0]
 0094 7C0000            xcall _LCD_1_PrString
 0097 20                pop X
 0098                   .dbline -2
 0098           L6:
 0098 38FB              add SP,-5
 009A 20                pop X
 009B                   .dbline 0 ; func end
 009B 7F                ret
 009C                   .dbsym l rgch 0 A[5:5]c
 009C                   .dbsym l hichdata -4 c
 009C                   .dbend
 009C                   .dbfunc e Dateneinlesen _Dateneinlesen fV
 009C           _Dateneinlesen::
 009C                   .dbline -1
 009C                   .dbline 177
 009C           ; 
 009C           ;       }
 009C           ;       
 009C           ; void Dateneinlesen(void)
 009C           ;       {       
 009C                   .dbline 179
 009C           ;       // Wenn Sollwertdaten bereit sind
 009C           ;       if(ADCINC_fIsDataAvailable() != 0)
 009C 10                push X
 009D 7C0000            xcall _ADCINC_fIsDataAvailable
 00A0 20                pop X
 00A1 3900              cmp A,0
 00A3 A008              jz L13
 00A5                   .dbline 183
 00A5           ;                       
 00A5           ;               // Einlesen des Sollwertes
 00A5           ;               // data ready flag zurüvksetzen        
 00A5           ;               prozess.pdchSollwert = ADCINC_cClearFlagGetData();              
 00A5 10                push X
 00A6 7C0000            xcall _ADCINC_cClearFlagGetData
 00A9 20                pop X
 00AA 5302              mov [_prozess+2],A
 00AC           L12:
 00AC                   .dbline 186
 00AC           ;                          
 00AC           ;       // Auf Entfernung und Position Warten
 00AC           ;               while(DUALADC8_fIsDataAvailable == 0);                  
 00AC           L13:
 00AC                   .dbline 186
 00AC 5000              mov A,<PL_DUALADC8_fIsDataAvailable
 00AE 10                push X
 00AF 5800              mov X,[__r1]
 00B1 08                push A
 00B2 28                romx
 00B3 5300              mov [__r0],A
 00B5 18                pop A
 00B6 75                inc X
 00B7 0900              adc A,0
 00B9 28                romx
 00BA 20                pop X
 00BB 3C0000            cmp [__r0],0
 00BE AFED              jz L12
 00C0                   .dbline 188
 00C0           ;               // Einlesen der Beschleunigung
 00C0           ;               prozess.pdchBechleunigung = DUALADC8_cGetData1();       
 00C0 10                push X
 00C1 7C0000            xcall _DUALADC8_cGetData1
 00C4 20                pop X
 00C5 5300              mov [_prozess],A
 00C7                   .dbline 192
 00C7           ;       
 00C7           ;               // Einlesen der Entfernung
 00C7           ;         // data ready flag zurüvksetzen         
 00C7           ;               prozess.pdchEntfernung = DUALADC8_cGetData2ClearFlag();         
 00C7 10                push X
 00C8 7C0000            xcall _DUALADC8_cGetData2ClearFlag
 00CB 20                pop X
 00CC 5301              mov [_prozess+1],A
 00CE                   .dbline -2
 00CE           L8:
 00CE                   .dbline 0 ; func end
 00CE 7F                ret
 00CF                   .dbend
 00CF                   .dbfunc e Ausgangansteuern _Ausgangansteuern fV
 00CF           ;            iin -> X+0
 00CF           ;   hichRichtung -> X-5
 00CF           ; hichAusgangswert -> X-4
 00CF           _Ausgangansteuern::
 00CF                   .dbline -1
 00CF 10                push X
 00D0 4F                mov X,SP
 00D1 3804              add SP,4
 00D3                   .dbline 196
 00D3           ;       }
 00D3           ; 
 00D3           ;       void Ausgangansteuern(char hichAusgangswert, char hichRichtung)
 00D3           ;       {
 00D3                   .dbline 201
 00D3           ;               // Variablendeklaration
 00D3           ;               int iin;
 00D3           ;               
 00D3           ;               // Drehrichtung Auswählen
 00D3           ;               switch(hichRichtung) {
 00D3 52FB              mov A,[X-5]
 00D5 5403              mov [X+3],A
 00D7 560200            mov [X+2],0
 00DA 3D0200            cmp [X+2],0
 00DD B006              jnz X1
 00DF 3D0301            cmp [X+3],1
 00E2 A00D              jz L20
 00E4           X1:
 00E4 3D0200            cmp [X+2],0
 00E7 B006              jnz X2
 00E9 3D0302            cmp [X+3],2
 00EC A039              jz L27
 00EE           X2:
 00EE 806D              xjmp L17
 00F0           L20:
 00F0                   .dbline 208
 00F0           ;                       // Linkslauf
 00F0           ;                       case 1: 
 00F0           ;                               
 00F0           ;                               //wenn sich die Drehrichtung ändert:
 00F0           ;                               //vorher 50 mal Bremsen
 00F0           ;                       
 00F0           ;                               if (IN2_GetState() == 1){
 00F0 10                push X
 00F1 7C0000            xcall _IN2_GetState
 00F4 20                pop X
 00F5 3901              cmp A,1
 00F7 B020              jnz L21
 00F9                   .dbline 209
 00F9           ;                                       for (iin = 0; iin < 50; iin ++)
 00F9                   .dbline 209
 00F9 560100            mov [X+1],0
 00FC 560000            mov [X+0],0
 00FF           L23:
 00FF                   .dbline 210
 00FF           ;                                               {
 00FF                   .dbline 211
 00FF           ;                                                       Ausgangansteuern(0, 0);
 00FF 5000              mov A,0
 0101 08                push A
 0102 08                push A
 0103 9FCA              xcall _Ausgangansteuern
 0105 38FE              add SP,-2
 0107                   .dbline 212
 0107           ;                                               }
 0107           L24:
 0107                   .dbline 209
 0107 7701              inc [X+1]
 0109 0F0000            adc [X+0],0
 010C                   .dbline 209
 010C 5201              mov A,[X+1]
 010E 1132              sub A,50
 0110 5200              mov A,[X+0]
 0112 3180              xor A,-128
 0114 1980              sbb A,(0 ^ 0x80)
 0116 CFE8              jc L23
 0118           X3:
 0118                   .dbline 213
 0118           ;                                       }
 0118           L21:
 0118                   .dbline 216
 0118           ;                                               
 0118           ;                               // IN1 und IN2 Ansteuern
 0118           ;                               IN1_Switch(0);
 0118 10                push X
 0119 5000              mov A,0
 011B 7C0000            xcall _IN1_Switch
 011E                   .dbline 217
 011E           ;                               IN2_Switch(1);
 011E 5001              mov A,1
 0120 7C0000            xcall _IN2_Switch
 0123 20                pop X
 0124                   .dbline 218
 0124           ;                               break;
 0124 8040              xjmp L18
 0126           L27:
 0126                   .dbline 223
 0126           ;                       
 0126           ;                       // Rechtslauf
 0126           ;                       case 2:
 0126           ;                               
 0126           ;                               if (IN2_GetState() == 1){
 0126 10                push X
 0127 7C0000            xcall _IN2_GetState
 012A 20                pop X
 012B 3901              cmp A,1
 012D B020              jnz L28
 012F                   .dbline 224
 012F           ;                                       for (iin = 0; iin < 50; iin ++)
 012F                   .dbline 224
 012F 560100            mov [X+1],0
 0132 560000            mov [X+0],0
 0135           L30:
 0135                   .dbline 225
 0135           ;                                               {
 0135                   .dbline 226
 0135           ;                                                       Ausgangansteuern(0, 0);
 0135 5000              mov A,0
 0137 08                push A
 0138 08                push A
 0139 9F94              xcall _Ausgangansteuern
 013B 38FE              add SP,-2
 013D                   .dbline 227
 013D           ;                                               }
 013D           L31:
 013D                   .dbline 224
 013D 7701              inc [X+1]
 013F 0F0000            adc [X+0],0
 0142                   .dbline 224
 0142 5201              mov A,[X+1]
 0144 1132              sub A,50
 0146 5200              mov A,[X+0]
 0148 3180              xor A,-128
 014A 1980              sbb A,(0 ^ 0x80)
 014C CFE8              jc L30
 014E           X4:
 014E                   .dbline 228
 014E           ;                                       }
 014E           L28:
 014E                   .dbline 230
 014E           ;                               
 014E           ;                               IN1_Switch(1);
 014E 10                push X
 014F 5001              mov A,1
 0151 7C0000            xcall _IN1_Switch
 0154                   .dbline 231
 0154           ;                               IN2_Switch(0);
 0154 5000              mov A,0
 0156 7C0000            xcall _IN2_Switch
 0159 20                pop X
 015A                   .dbline 232
 015A           ;                               break;
 015A 800A              xjmp L18
 015C           L17:
 015C                   .dbline 236
 015C           ;                       // Ungültiger Wert
 015C           ;                       default:
 015C           ;                               // Pulsweite auf 0 setzen
 015C           ;                               PWM8_1_WritePulseWidth(0);
 015C 10                push X
 015D 5000              mov A,0
 015F 7C0000            xcall _PWM8_1_WritePulseWidth
 0162 20                pop X
 0163                   .dbline 238
 0163           ;                               // Funktion verlassen
 0163           ;                               return ;
 0163 8008              xjmp L16
 0165           L18:
 0165                   .dbline 243
 0165           ;                               
 0165           ;                       }
 0165           ;               
 0165           ;               // Pulsweite auf hichAusgangswert setzen                
 0165           ;               PWM8_1_WritePulseWidth(hichAusgangswert);
 0165 10                push X
 0166 52FC              mov A,[X-4]
 0168 7C0000            xcall _PWM8_1_WritePulseWidth
 016B 20                pop X
 016C                   .dbline -2
 016C           L16:
 016C 38FC              add SP,-4
 016E 20                pop X
 016F                   .dbline 0 ; func end
 016F 7F                ret
 0170                   .dbsym l iin 0 I
 0170                   .dbsym l hichRichtung -5 c
 0170                   .dbsym l hichAusgangswert -4 c
 0170                   .dbend
 0170                   .dbfunc e test _test fV
 0170           ;            iin -> X+0
 0170           ;       hichdata -> X-4
 0170           _test::
 0170                   .dbline -1
 0170 10                push X
 0171 4F                mov X,SP
 0172 3802              add SP,2
 0174                   .dbline 319
 0174           ;       }
 0174           ;       
 0174           ;       
 0174           ;       
 0174           ;       
 0174           ;       
 0174           ;       /*
 0174           ; void Ausgangansteuern(char hichAusgangswert, char hichRichtung)
 0174           ;       {
 0174           ;               int iin;
 0174           ;               // Korekturfaktor zur 
 0174           ;               // bestimmung der Pulsweite:
 0174           ;               char kochKorekturfaktor = 1;
 0174           ;               
 0174           ;               // Seil Abwickeln 
 0174           ;               
 0174           ;               if (hichRichtung == 1){
 0174           ;                       
 0174           ;                       //wenn sich die Drehrichtung ändert:
 0174           ;                       //vorher 100 mal Bremsen
 0174           ;                       
 0174           ;                       if (IN2_GetState() == 1){
 0174           ;                               for (iin = 0; iin < 100; iin ++)
 0174           ;                                       {
 0174           ;                                               Ausgangansteuern(0, 0);
 0174           ;                                       }
 0174           ;                               
 0174           ;                       }
 0174           ;                       // Ausgänge ansteuern
 0174           ;                       IN1_Switch(1);
 0174           ;                       IN2_Switch(0);
 0174           ;                       PWM8_1_Stop();
 0174           ;                       PWM8_1_WritePulseWidth(hichAusgangswert * kochKorekturfaktor);
 0174           ;                       PWM8_1_Start();
 0174           ;               }
 0174           ;               
 0174           ;               // Seil Aufwickeln
 0174           ;               
 0174           ;               else if (hichRichtung == 2){
 0174           ;                                       
 0174           ;                       //wenn sich die Drehrichtung ändert:
 0174           ;                       //vorher 100 mal Bremsen
 0174           ;                       if (IN1_GetState() == 1){
 0174           ;                                       for (iin = 0; iin < 100; iin ++)
 0174           ;                                               {
 0174           ;                                                       Ausgangansteuern(0, 0);
 0174           ;                                               }
 0174           ;                                               
 0174           ;                               } 
 0174           ;                       // Klammer zu Fiel Warum
 0174           ;                       // Ausgänge ansteuern
 0174           ;                       IN1_Switch(0);
 0174           ;                       IN2_Switch(1);
 0174           ;                       PWM8_1_Stop();
 0174           ;                       PWM8_1_WritePulseWidth(hichAusgangswert * kochKorekturfaktor);
 0174           ;                       PWM8_1_Start();
 0174           ;                       }
 0174           ;       
 0174           ;               // Bremsen durch Leerlauf
 0174           ;               else {                          
 0174           ;                       // Ausgänge ansteuern
 0174           ;                       IN1_Switch(1);
 0174           ;                       IN2_Switch(1);
 0174           ;                       PWM8_1_Stop();
 0174           ;                       PWM8_1_WritePulseWidth(0);
 0174           ;                       PWM8_1_Start();
 0174           ;                       }
 0174           ;               
 0174           ;       }
 0174           ;       */
 0174           ;       
 0174           ; // Präprozessor: kompiliere Funktion nur wenn Test
 0174           ; #ifdef TEST
 0174           ;       // Ausgabe der Testdaten auf LCD-Display
 0174           ;       void test(char hichdata)
 0174           ;               {
 0174                   .dbline 322
 0174           ;               // gibt 99999 mal LCD Aus
 0174           ;               int iin;
 0174           ;               for (iin = 0; iin <= 500; iin ++)
 0174 560100            mov [X+1],0
 0177 560000            mov [X+0],0
 017A           L35:
 017A                   .dbline 323
 017A           ;                       {
 017A                   .dbline 324
 017A           ;                       LCDansteuern(hichdata); 
 017A 52FC              mov A,[X-4]
 017C 08                push A
 017D 9EE2              xcall _LCDansteuern
 017F 38FF              add SP,-1
 0181                   .dbline 325
 0181           ;                       }
 0181           L36:
 0181                   .dbline 322
 0181 7701              inc [X+1]
 0183 0F0000            adc [X+0],0
 0186                   .dbline 322
 0186 50F4              mov A,-12
 0188 1301              sub A,[X+1]
 018A 5200              mov A,[X+0]
 018C 3180              xor A,-128
 018E 5300              mov [__rX],A
 0190 5081              mov A,(1 ^ 0x80)
 0192 1A00              sbb A,[__rX]
 0194 DFE5              jnc L35
 0196           X5:
 0196                   .dbline -2
 0196           L34:
 0196 38FE              add SP,-2
 0198 20                pop X
 0199                   .dbline 0 ; func end
 0199 7F                ret
 019A                   .dbsym l iin 0 I
 019A                   .dbsym l hichdata -4 c
 019A                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile C:\Users\Lesky\Desktop\NEUERO~1\SEEGAN~1\SEEGAN~1\main.c
 0000           _prozess::
 0000                   .blkb 3
 0003                   .dbstruct 0 3 .1
 0003                   .dbfield 0 pdchBechleunigung c
 0003                   .dbfield 1 pdchEntfernung c
 0003                   .dbfield 2 pdchSollwert c
 0003                   .dbend
 0003                   .dbsym e prozess _prozess S[.1]
                        .area lit(rom, con, rel, lit)
 0000           L7:
 0000 576572743A00      .byte 'W,'e,'r,'t,58,0
                        .area func_lit(rom, con, rel, proclab)
 0000 0000      PL_DUALADC8_fIsDataAvailable:   .word _DUALADC8_fIsDataAvailable
